{"componentChunkName":"component---src-templates-work-js","path":"/works/Hexells/view.html","result":{"pageContext":{"pagePath":"works/Hexells/view.html","content":"<!doctype html>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0\">\n<script src=\"twgl-full.min.js\"></script>\n<script src=\"dat.gui.min.js\"></script>\n<script src=\"seedrandom.min.js\"></script>\n<script src=\"ca.js\" type=\"module\"></script>\n\n<style>\nhtml, body {\n  margin: 0px;\n  font-family: 'Google Sans', Arial, Helvetica, sans-serif;\n  overflow: hidden;\n  color: #FFF;\n}\ncanvas {\n  width: 100vw;\n  max-width: 100%;\n  height: 100vh;\n  max-height: 100%;\n}\n\n#fsButton {\n  position: fixed;\n  z-index: 10;\n  bottom: 20px; left:20px;\n}\n\n.centered { \n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n#info{\n  width: 300px;\n  background-color: rgba(0, 0, 0, 0.75);\n  padding: 20px;\n  z-index:5;\n}\n\na:link {\n  color: red;\n}\n\na:visited {\n  color: red;\n}\n\n.hint {\n  font-size: min(10vw, 8vh);\n  pointer-events: none;\n  white-space: nowrap;\n  opacity: 0;\n}\n\n.hint-anim {\n  animation: fadeIn linear 2s;\n}\n@keyframes fadeIn {\n  0% {opacity:0;}\n  10% {opacity:1;}\n  90% {opacity:1;}\n  100% {opacity:0;}\n}\n</style>\n\n<div id='hint' class='centered hint'>⇦ Swipe ⇨</div>\n\n<div id='info' class='centered'>\n  <p> <b style=\"font-size: large;\">Hexells</b>\n  <span style=\"font-size: smaller;\">by <a href=\"https://twitter.com/zzznah\">Alexander Mordvintsev</a><span>\n\n  <p>\n    is a Self-Organising System of cells, that was trained to build textures\n    using neighbour communication only. This work exposes the relation between\n    the life an individual cell, and the cell collective as a whole.\n  </p>\n  <p>     The system is based on the \n    <a href=\"https://distill.pub/2020/growing-ca/\">Neural Cellular Automata</a>.\n</p>\n\n<p style=\"font-size: large;\">\n  Touch to interact; swipe left or right to change the pattern.\n</p>\n\n<div id=\"hideBtn\" style=\"text-align: center;\"><button>Hide</button></div>\n</div>\n\n<canvas id=\"glCanvas\"></canvas>\n<button id=\"fsButton\">Fullscreen</button>\n\n\n<script type=\"module\">\n  import { CA } from \"./ca.js\"\n\n  const $ = q=>document.querySelector(q);\n\n  const canvas = $('#glCanvas');\n\n  const requestFullscreen = canvas.requestFullscreen\n      || canvas.webkitRequestFullscreen || canvas.msRequestFullscreen;\n  if (requestFullscreen === undefined) {\n    $('#fsButton').style.display = 'none';\n  }\n\n  $('#fsButton').onclick = ()=>{\n    const elem = canvas;\n    const opt = { navigationUI: \"hide\" };\n    if (elem.requestFullscreen) {\n      elem.requestFullscreen(opt);\n    } else if (elem.webkitRequestFullscreen) { /* Safari */\n      elem.webkitRequestFullscreen(opt);\n    } else if (elem.msRequestFullscreen) { /* IE11 */\n      elem.msRequestFullscreen(opt);\n    }\n  };\n  \n  $('#hideBtn').onclick = ()=>{\n    $('#info').style.display = 'none';\n    $('#hint').classList.add('hint-anim');\n\n  };\n\n  const gl = canvas.getContext(\"webgl\");\n  const gui = new dat.GUI();\n  gui.hide();\n  const param = {\n    active: true,\n    model: 149,\n    brushRadius: 16,\n    zoom: 1,\n    stepPerFrame: 1,\n    paintMode: false,\n  };\n  gui.add(param, 'active');\n  gui.add(param, 'brushRadius', 1, 40);\n  gui.add(param, 'zoom', 1.0, 64.0);\n  gui.add(param, 'stepPerFrame', 0, 6);\n  gui.add(param, 'paintMode', 0, 6);\n\n  const query = new URLSearchParams(location.search);\n  const seed = parseInt(query.get(\"seed\"));\n  if (seed) Math.seedrandom(seed);\n  const page = parseInt(query.get(\"page\"));\n  \n  fetch('models.json').then(r => r.json()).then(models => {\n    const onready = ()=>{\n      if (page && seed) {\n        param.active = false;\n        const pageModels = [132, 149, 134, 168, 104];\n        ca.paint(0, 0, -1, pageModels[page-1]);\n        ca.disturb();\n\n        for (let i=0; i<400; ++i) ca.step();\n        $('#fsButton').style.display = \"none\";\n        $('#info').style.display = 'none';\n        canvas.width = 2412;\n        canvas.height = 3074;\n        const viewSize = [canvas.width, canvas.height];\n        twgl.bindFramebufferInfo(gl);\n        ca.draw(viewSize);\n        const a = document.createElement('a');\n        a.href = canvas.toDataURL(\"image/png\");\n        a.download = seed + '_' + page + '.png';\n        a.click();\n      }\n    };\n    const ca = new CA(gl, models, [160, 160], gui, onready);\n    window.ca = ca;\n    ca.alignment = 0;\n    \n    const name2idx = Object.fromEntries(models.model_names.map((s, i) => [s, i]));\n    gui.add(param, 'model').options(name2idx).listen();\n\n    function getMousePos(e) {\n      return [e.offsetX, e.offsetY];\n    }\n    function getTouchPos(touch) {\n      const rect = canvas.getBoundingClientRect();\n      return [touch.clientX - rect.left, touch.clientY - rect.top];\n    }\n\n    const shuffledModels = models.model_names.map((_, i)=>[Math.random(), i]).sort().map(p=>p[1]);\n    let initModelIdx = parseInt(window.location.hash.slice(1));\n    if (isNaN(initModelIdx) || initModelIdx < 0 || initModelIdx >= shuffledModels.length) {\n      initModelIdx = 132;\n    }\n    console.log(initModelIdx);\n    ca.paint(0, 0, -1, initModelIdx);\n    let curModel = shuffledModels.indexOf(initModelIdx);\n    let gesture = null;\n    function startGestue(pos) {\n      gesture = {\n        l: 0, r: 0, u: 0, d: 0,\n        prevPos: pos,\n        time: Date.now()\n      };\n    }\n    function touch(pos) {\n      const [x, y] = pos;\n      const viewSize = [canvas.clientWidth, canvas.clientHeight];\n      if ( param.paintMode ) {\n        ca.paint(x, y, param.brushRadius, param.model, viewSize);\n      } else {\n        ca.clearCircle(x, y, param.brushRadius, viewSize);\n      }\n      if (gesture) {\n        const [x0, y0] = gesture.prevPos;\n        gesture.l += Math.max(x0-x, 0.0);\n        gesture.r += Math.max(x-x0, 0.0);\n        gesture.u += Math.max(y0-y, 0.0);\n        gesture.d += Math.max(y-y0, 0.0);\n        gesture.prevPos = pos;\n      }\n    }    \n    function endGestue(pos) {\n      if (!gesture)\n       return;\n      if (Date.now()-gesture.time < 1000) {\n        const {l, r, u, d} = gesture;\n        let swipe = 0;\n        if (l>100 && Math.max(r, u, d)<l*0.25) swipe = -1;\n        if (r>100 && Math.max(l, u, d)<r*0.25) swipe = 1;\n        if (swipe != 0)  {\n            const n = shuffledModels.length;\n            curModel = (curModel+n+swipe) % n;\n            const i = shuffledModels[curModel];\n            ca.paint(0, 0, -1, i);\n            ca.disturb();\n            console.log(i);\n            //window.location.hash = i;\n        }\n      }\n      gesture = null;\n    }\n\n    canvas.onmousedown = e => {\n      e.preventDefault();\n      if (e.buttons == 1) {\n        const pos = getMousePos(e);\n        touch(pos);\n        startGestue(pos);\n      }\n    }\n    canvas.onmousemove = e => {\n      e.preventDefault();\n      if (e.buttons == 1) {\n        touch(getMousePos(e));\n      }\n    }\n    canvas.onmouseup = e => {\n      e.preventDefault();\n      endGestue(getMousePos(e));\n    }\n\n    canvas.addEventListener(\"touchstart\", e => {\n      e.preventDefault();\n      const pos = getTouchPos(e.changedTouches[0]);\n      touch(pos);\n      if (e.touches.length == 1) {\n        startGestue(pos);\n      } else {\n        gesture = null; //cancel guesture\n      }\n    });\n    canvas.addEventListener(\"touchmove\", e => {\n      e.preventDefault();\n      for (const t of e.touches) {\n        touch(getTouchPos(t));\n      }\n    });\n    canvas.addEventListener(\"touchend\", e => {\n      e.preventDefault();\n      endGestue(getTouchPos(e.changedTouches[0]));\n    });\n    param.benchmark = ()=>{\n      $('#log').insertAdjacentHTML('afterbegin', ca.benchmark());\n    }\n    gui.add(param, 'benchmark');\n\n    function render() {\n      if (param.active) {\n        ca.step();\n      }\n      \n      const devicePixelRatio = window.devicePixelRatio || 1;\n      canvas.width = Math.round(canvas.clientWidth * devicePixelRatio);\n      canvas.height = Math.round(canvas.clientHeight * devicePixelRatio);      \n      const viewSize = [canvas.clientWidth, canvas.clientHeight];\n\n      twgl.bindFramebufferInfo(gl);\n      ca.draw(viewSize);\n\n      requestAnimationFrame(render);\n    }\n\n    requestAnimationFrame(render);\n  })\n</script>\n","url":"Hexells"}},"staticQueryHashes":[]}