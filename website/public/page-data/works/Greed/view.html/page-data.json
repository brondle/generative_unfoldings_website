{"componentChunkName":"component---src-templates-work-js","path":"/works/greed/view.html","result":{"pageContext":{"pagePath":"works/greed/view.html","content":"<!DOCTYPE HTML>\n<html lang=\"en\">\n\t<head>\n\t\t<title>Greed</title>\n\t\t<meta charset=\"utf-8\">\n\t\t<meta name=\"viewport\" content=\"width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0\">\n\t\t<style type=\"text/css\">\n\t\t\tbody {\n\t\t\t\tbackground: #000;\n\t\t\t\tcolor: #999;\n\t\t\t\tpadding: 0;\n\t\t\t\tmargin: 0;\n\t\t\t\toverflow: hidden;\n\t\t\t\tfont-family: georgia;\n\t\t\t\tfont-size:0.6em;\n\t\t\t\ttext-align: center;\n\t\t\t}\n\n\t\t\ta { color: #f60; }\n\n\t\t\t#footer { position: absolute; bottom: 40px; width: 100%; }\n\t\t\t.h { color: #f60 }\n\t\t\t.c { display: inline; margin-left: 1em }\n\n\t\t\t#player-container #play-pause {\n\t\t  cursor: pointer;\n\t\t  text-indent: -999999px;\n\t\t  height:12px;\n\t\t  width: 12px;\n\t\t  padding: 5px 6px;\n\t\t  z-index: 2;\n\t\t    background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMiAyNHYtMjRsMjAgMTItMjAgMTJ6Ii8+PC9zdmc+);\n\t\t    background-repeat: no-repeat!important;\n\t\t    background-position: center;\n\t\t    background-size: 12px;\n\t\t  background-color: #f60;\n\t\t}\n\t\t.play {\n\t\t  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMiAyNHYtMjRsMjAgMTItMjAgMTJ6Ii8+PC9zdmc+);\n\t\t}\n\t\t.pause {\n\t\t   background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTAgMjRoLTZ2LTI0aDZ2MjR6bTEwLTI0aC02djI0aDZ2LTI0eiIvPjwvc3ZnPg==)!important;\n\t\t}\n\n\t\t</style>\n\t</head>\n\n\t<body>\n\t\t<div id=\"container\"></div>\n\n\n\t\t<div id=\"footer\">\n\t\t\t<div class=\"c\">\n\t\t\tanimate terrain: <span class=\"h\">m</span>\n\t\t\t</div> &nbsp;&nbsp;&nbsp;&nbsp; rendered by <a href=\"http://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a>  using\n\t\t\t\t\t\t<a href=\"https://github.com/ashima/webgl-noise\" target=\"_blank\" rel=\"noopener\">simplex noise</a><br/>\n\n\t\t\t\t\t\t<audio id=\"track\">\n  <source src=\"sounds/greed.mp3\" type=\"audio/mpeg\" />\n\t <source src=\"sounds/greed.ogg\" type=\"audio/ogg\" />\n</audio>\n\n<div id=\"player-container\">\n  <div id=\"play-pause\" class=\"play\"></div>\n</div>\n\n\t\t\t</div>\n\n\n\t\t<script src=\"build/three.js\"></script>\n\n\t\t<script src=\"js/seedrandom.min.js\"></script>\n\n\t\t<script src=\"js/controls/OrbitControls.js\"></script>\n\n\t\t<script src=\"js/BufferGeometryUtils.js\"></script>\n\n\t\t<script src=\"js/shaders/NormalMapShader.js\"></script>\n\n\t\t<script src=\"js/ShaderTerrain.js\"></script>\n\n\t\t<script src=\"js/Detector.js\"></script>\n\n<script>\nvar track = document.getElementById('track');\n\nvar controlBtn = document.getElementById('play-pause');\n\nfunction playPause() {\n    if (track.paused) {\n        track.play();\n        //controlBtn.textContent = \"Pause\";\n        controlBtn.className = \"pause\";\n    } else {\n        track.pause();\n         //controlBtn.textContent = \"Play\";\n        controlBtn.className = \"play\";\n    }\n}\n\ncontrolBtn.addEventListener(\"click\", playPause);\ntrack.addEventListener(\"ended\", function() {\n  controlBtn.className = \"play\";\n});\n</script>\n\n\t\t<script id=\"fragmentShaderNoise\" type=\"x-shader/x-fragment\">\n\n\t\t\t//\n\t\t\t// Description : Array and textureless GLSL 3D simplex noise function.\n\t\t\t//      Author : Ian McEwan, Ashima Arts.\n\t\t\t//  Maintainer : ijm\n\t\t\t//     Lastmod : 20110409 (stegu)\n\t\t\t//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\t\t\t//               Distributed under the MIT License. See LICENSE file.\n\t\t\t//\n\n\t\t\tuniform float time;\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvec4 permute( vec4 x ) {\n\n\t\t\t\treturn mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );\n\n\t\t\t}\n\n\t\t\tvec4 taylorInvSqrt( vec4 r ) {\n\n\t\t\t\treturn 1.79284291400159 - 0.85373472095314 * r;\n\n\t\t\t}\n\n\t\t\tfloat snoise( vec3 v ) {\n\n\t\t\t\tconst vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n\t\t\t\tconst vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );\n\n\t\t\t\t// First corner\n\n\t\t\t\tvec3 i  = floor( v + dot( v, C.yyy ) );\n\t\t\t\tvec3 x0 = v - i + dot( i, C.xxx );\n\n\t\t\t\t// Other corners\n\n\t\t\t\tvec3 g = step( x0.yzx, x0.xyz );\n\t\t\t\tvec3 l = 1.0 - g;\n\t\t\t\tvec3 i1 = min( g.xyz, l.zxy );\n\t\t\t\tvec3 i2 = max( g.xyz, l.zxy );\n\n\t\t\t\tvec3 x1 = x0 - i1 + 1.0 * C.xxx;\n\t\t\t\tvec3 x2 = x0 - i2 + 2.0 * C.xxx;\n\t\t\t\tvec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n\t\t\t\t// Permutations\n\n\t\t\t\ti = mod( i, 289.0 );\n\t\t\t\tvec4 p = permute( permute( permute(\n\t\t\t\t\t\t i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )\n\t\t\t\t\t   + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )\n\t\t\t\t\t   + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\n\n\t\t\t\t// Gradients\n\t\t\t\t// ( N*N points uniformly over a square, mapped onto an octahedron.)\n\n\t\t\t\tfloat n_ = 1.0 / 7.0; // N=7\n\n\t\t\t\tvec3 ns = n_ * D.wyz - D.xzx;\n\n\t\t\t\tvec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)\n\n\t\t\t\tvec4 x_ = floor( j * ns.z );\n\t\t\t\tvec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)\n\n\t\t\t\tvec4 x = x_ *ns.x + ns.yyyy;\n\t\t\t\tvec4 y = y_ *ns.x + ns.yyyy;\n\t\t\t\tvec4 h = 1.0 - abs( x ) - abs( y );\n\n\t\t\t\tvec4 b0 = vec4( x.xy, y.xy );\n\t\t\t\tvec4 b1 = vec4( x.zw, y.zw );\n\n\n\t\t\t\tvec4 s0 = floor( b0 ) * 2.0 + 1.0;\n\t\t\t\tvec4 s1 = floor( b1 ) * 2.0 + 1.0;\n\t\t\t\tvec4 sh = -step( h, vec4( 0.0 ) );\n\n\t\t\t\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\t\t\t\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n\t\t\t\tvec3 p0 = vec3( a0.xy, h.x );\n\t\t\t\tvec3 p1 = vec3( a0.zw, h.y );\n\t\t\t\tvec3 p2 = vec3( a1.xy, h.z );\n\t\t\t\tvec3 p3 = vec3( a1.zw, h.w );\n\n\t\t\t\t// Normalise gradients\n\n\t\t\t\tvec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\n\t\t\t\tp0 *= norm.x;\n\t\t\t\tp1 *= norm.y;\n\t\t\t\tp2 *= norm.z;\n\t\t\t\tp3 *= norm.w;\n\n\t\t\t\t// Mix final noise value\n\n\t\t\t\tvec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n\t\t\t\tm = m * m;\n\t\t\t\treturn 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),\n\t\t\t\t\t\t\t\t\t\t\t  dot( p2, x2 ), dot( p3, x3 ) ) );\n\n\t\t\t}\n\n\t\t\tfloat surface3( vec3 coord ) {\n\n\t\t\t\tfloat n = 0.0;\n\n\t\t\t\tn += 1.0 * abs( snoise( coord ) );\n\t\t\t\tn += 0.5 * abs( snoise( coord * 2.0 ) );\n\t\t\t\tn += 0.25 * abs( snoise( coord * 4.0 ) );\n\t\t\t\tn += 0.125 * abs( snoise( coord * 8.0 ) );\n\n\t\t\t\treturn n;\n\n\t\t\t}\n\n\t\t\tvoid main( void ) {\n\n\t\t\t\tvec3 coord = vec3( vUv, -time );\n\t\t\t\tfloat n = surface3( coord );\n\n\t\t\t\tgl_FragColor = vec4( vec3( n, n, n ), 1.0 );\n\n\t\t\t}\n\n\t\t</script>\n\n\n\t\t<script id=\"vertexShader\" type=\"x-shader/x-vertex\">\n\n\t\t\tvarying vec2 vUv;\n\t\t\tuniform vec2 scale;\n\t\t\tuniform vec2 offset;\n\n\t\t\tvoid main( void ) {\n\n\t\t\t\tvUv = uv * scale + offset;\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t}\n\n\t\t</script>\n\n\t\t<script>\n\n\t\t\tif ( ! Detector.webgl ) Detector.addGetWebGLMessage();\n\n\t\t\tvar SCREEN_WIDTH = window.innerWidth;\n\t\t\tvar SCREEN_HEIGHT = window.innerHeight;\n\t\t\tconst PAGE_WIDTH = 2412;\n\t\t\tconst PAGE_HEIGHT = 3074;\n\t\t\tvar renderer, container, stats;\n\n\t\t\tvar camera, scene, controls;\n\t\t\tvar cameraOrtho, sceneRenderTarget;\n\n\t\t\tvar uniformsNoise, uniformsNormal, uniformsTerrain,\n\t\t\t\theightMap, normalMap,\n\t\t\t\tquadTarget;\n\n\t\t\tvar directionalLight, pointLight;\n\n\t\t\tvar terrain;\n\n\t\t\tvar textureCounter = 0;\n\n\t\t\tvar animDelta = 0, animDeltaDir = -1;\n\t\t\tvar lightVal = 0, lightDir = 1;\n\n\n\t\t\tvar clock = new THREE.Clock();\n\n\t\t\tvar updateNoise = true;\n\n\t\t\tvar animateTerrain = false;\n\n\t\t\tvar mlib = {};\n\n\t\t\tconst urlParams = new URLSearchParams(location.search);\n\t\t\tconst seed = parseInt(urlParams.get(\"seed\"));\n\t\t\tconst page = parseInt(urlParams.get(\"page\"));\n\t\t\t//create a random number generator with our designated seed\n\t\t\tconst rng = new Math.seedrandom(seed);\n\t\t\tvar randomNumber;\n\n\t\t\tinit();\n\t\t\tanimate();\n\n\t\t\tfunction init() {\n\n\t\t\t\tcontainer = document.getElementById( 'container' );\n\n\n\t\t\t\t// SCENE (RENDER TARGET)\n\n\t\t\t\tsceneRenderTarget = new THREE.Scene();\n\n\t\t\t\tcameraOrtho = new THREE.OrthographicCamera( SCREEN_WIDTH / - 2, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, SCREEN_HEIGHT / - 2, -10000, 10000 );\n\t\t\t\tcameraOrtho.position.z = 100;\n\n\t\t\t\tsceneRenderTarget.add( cameraOrtho );\n\n\t\t\t\t// CAMERA\n\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, SCREEN_WIDTH / SCREEN_HEIGHT, 2, 4000 );\n\t\t\t\tcamera.position.set( -1200, 500, 1000 );// ( -1200, 800, 1200 )\n\n\t\t\t\tcontrols = new THREE.OrbitControls( camera );\n\t\t\t\tcontrols.target.set( 0, 0, 0 );\n\n\t\t\t\tcontrols.enableRotate = true;\n\t\t\t\t//adding a bit of heaviness here (heft)\n\t\t\t\tcontrols.rotateSpeed = 0.05;\n\t\t\t\tcontrols.minAzimuthAngle = - Math.PI; // default\n\t\t\t\tcontrols.maxAzimuthAngle = Math.PI / 2;\n\n\t\t\t\tcontrols.minPolarAngle = 0; // default\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 3;\n\n        //and a bit of heaviness here\n\t\t\t\tcontrols.zoomSpeed = 0.05;\n\n\t\t\t\tcontrols.panSpeed = 0.5;\n\n\t\t\t\tcontrols.enableKeys= true;\n\t\t\t\tcontrols.keys = [ 37, 38, 39 ];\n\n\t\t\t\t// SCENE (FINAL)\n\n\t\t\t\tscene = new THREE.Scene();\n\t\t\t\tscene.fog = new THREE.Fog( 0x050505, 2000, 4000 );\n\n\t\t\t\t// LIGHTS\n\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x111111 ) );\n\n\t\t\t\tdirectionalLight = new THREE.DirectionalLight( 0xffffff, 1.15 );\n\t\t\t\tdirectionalLight.position.set( 500, 2000, 0 );\n\t\t\t\tscene.add( directionalLight );\n\n\t\t\t\tpointLight = new THREE.PointLight( 0xff4400, 1.5 );\n\t\t\t\tpointLight.position.set( 0, 0, 0 );\n\t\t\t\tscene.add( pointLight );\n\n\n\t\t\t\t// HEIGHT + NORMAL MAPS\n\n\t\t\t\tvar normalShader = THREE.NormalMapShader;\n\n\t\t\t\tvar rx = 256, ry = 256;\n\t\t\t\t// var rx = 2412, ry = 3074;\n\t\t\t\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };\n\n\t\t\t\theightMap  = new THREE.WebGLRenderTarget( rx, ry, pars );\n\t\t\t\theightMap.texture.generateMipmaps = false;\n\n\t\t\t\tnormalMap = new THREE.WebGLRenderTarget( rx, ry, pars );\n\t\t\t\tnormalMap.texture.generateMipmaps = false;\n\n\t\t\t\tuniformsNoise = {\n\n\t\t\t\t\ttime:   { value: 1.0 },\n\t\t\t\t\tscale:  { value: new THREE.Vector2( 1.5, 1.5 ) },\n\t\t\t\t\toffset: { value: new THREE.Vector2( 0, 0 ) }\n\n\t\t\t\t};\n\n\t\t\t\tuniformsNormal = THREE.UniformsUtils.clone( normalShader.uniforms );\n\n\t\t\t\tuniformsNormal.height.value = 0.05;\n\t\t\t\tuniformsNormal.resolution.value.set( rx, ry );\n\t\t\t\tuniformsNormal.heightMap.value = heightMap.texture;\n\n\t\t\t\tvar vertexShader = document.getElementById( 'vertexShader' ).textContent;\n\n\t\t\t\t// TEXTURES\n\n\t\t\t\tvar loadingManager = new THREE.LoadingManager( function(){\n\t\t\t\t\tterrain.visible = true;\n\t\t\t\t});\n\t\t\t\tvar textureLoader = new THREE.TextureLoader( loadingManager );\n\n\t\t\t\tvar specularMap = new THREE.WebGLRenderTarget( 1024, 1024, pars );\n\t\t\t\tspecularMap.texture.generateMipmaps = false;\n\n\t\t\t\tvar diffuseTexture1 = textureLoader.load( \"./textures/difTex001.png\" );\n\t\t\t\tvar diffuseTexture2 = textureLoader.load( \"./textures/difTex002.png\" );\n\t\t\t\t//on purpose here\n\t\t\t\tvar detailTexture = textureLoader.load( \"textures/consenttocollectmydata.png\" );\n\n\t\t\t\tdiffuseTexture1.wrapS = diffuseTexture1.wrapT = THREE.RepeatWrapping;\n\t\t\t\tdiffuseTexture2.wrapS = diffuseTexture2.wrapT = THREE.RepeatWrapping;\n\t\t\t\tdetailTexture.wrapS = detailTexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\tspecularMap.texture.wrapS = specularMap.texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t// TERRAIN SHADER\n\n\t\t\t\tvar terrainShader = THREE.ShaderTerrain[ \"terrain\" ];\n\n\t\t\t\tuniformsTerrain = THREE.UniformsUtils.clone( terrainShader.uniforms );\n\n\t\t\t\tuniformsTerrain[ 'tNormal' ].value = normalMap.texture;\n\t\t\t\tuniformsTerrain[ 'uNormalScale' ].value = 3.5;\n\n\t\t\t\tuniformsTerrain[ 'tDisplacement' ].value = heightMap.texture;\n\n\t\t\t\tuniformsTerrain[ 'tDiffuse1' ].value = diffuseTexture1;\n\t\t\t\tuniformsTerrain[ 'tDiffuse2' ].value = diffuseTexture2;\n\t\t\t\tuniformsTerrain[ 'tSpecular' ].value = specularMap.texture;\n\t\t\t\tuniformsTerrain[ 'tDetail' ].value = detailTexture;\n\n\t\t\t\tuniformsTerrain[ 'enableDiffuse1' ].value = true;\n\t\t\t\tuniformsTerrain[ 'enableDiffuse2' ].value = true;\n\t\t\t\tuniformsTerrain[ 'enableSpecular' ].value = true;\n\n\t\t\t\tuniformsTerrain[ 'diffuse' ].value.setHex( 0xffffff );\n\t\t\t\tuniformsTerrain[ 'specular' ].value.setHex( 0xffffff );\n\n\t\t\t\tuniformsTerrain[ 'shininess' ].value = 30;\n\n\t\t\t\tuniformsTerrain[ 'uDisplacementScale' ].value = 375;\n\n\t\t\t\tuniformsTerrain[ 'uRepeatOverlay' ].value.set( 6, 6 );\n\n\t\t\t\tvar params = [\n\t\t\t\t\t[ 'heightmap', \tdocument.getElementById( 'fragmentShaderNoise' ).textContent, \tvertexShader, uniformsNoise, false ],\n\t\t\t\t\t[ 'normal', \tnormalShader.fragmentShader,  normalShader.vertexShader, uniformsNormal, false ],\n\t\t\t\t\t[ 'terrain', \tterrainShader.fragmentShader, terrainShader.vertexShader, uniformsTerrain, true ]\n\t\t\t\t ];\n\n\t\t\t\tfor( var i = 0; i < params.length; i ++ ) {\n\n\t\t\t\t\tvar material = new THREE.ShaderMaterial( {\n\n\t\t\t\t\t\tuniforms: \t\tparams[ i ][ 3 ],\n\t\t\t\t\t\tvertexShader: \tparams[ i ][ 2 ],\n\t\t\t\t\t\tfragmentShader: params[ i ][ 1 ],\n\t\t\t\t\t\tlights: \t\tparams[ i ][ 4 ],\n\t\t\t\t\t\tfog: \t\t\ttrue\n\t\t\t\t\t\t} );\n\n\t\t\t\t\tmlib[ params[ i ][ 0 ] ] = material;\n\n\t\t\t\t}\n\n\n\t\t\t\tvar plane = new THREE.PlaneBufferGeometry( SCREEN_WIDTH, SCREEN_HEIGHT );\n\n\t\t\t\tquadTarget = new THREE.Mesh( plane, new THREE.MeshBasicMaterial( { color: 0x000000 } ) );\n\t\t\t\tquadTarget.position.z = -500;\n\t\t\t\tsceneRenderTarget.add( quadTarget );\n\n\t\t\t\t// TERRAIN MESH\n\n\t\t\t\tvar geometryTerrain = new THREE.PlaneBufferGeometry( 9000, 9000, 256, 256 );\n\n\t\t\t\tTHREE.BufferGeometryUtils.computeTangents( geometryTerrain );\n\n\t\t\t\tterrain = new THREE.Mesh( geometryTerrain, mlib[ 'terrain' ] );\n\t\t\t\tterrain.position.set( 0, -125, 0 );\n\t\t\t\tterrain.rotation.x = -Math.PI / 2;\n\t\t\t\tterrain.visible = false;\n\t\t\t\tscene.add( terrain );\n\n\t\t\t\t// RENDERER\n\n\t\t\t\trenderer = new THREE.WebGLRenderer();\n\t\t\t\trenderer.setClearColor( scene.fog.color );\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\t\t\t\tcontainer.appendChild( renderer.domElement );\n\n\n\t\t\t\t// EVENTS\n\n\t\t\t\tonWindowResize();\n\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\n\n\t\t\t\tdocument.addEventListener( 'keydown', onKeyDown, false );\n\n\t\t\t\tif (seed && page) {\n\t\t\t\t\tfor (var i = 1; i <= page - 1; i++) {\n\t\t\t\t\t\t// every time this is called, it hits our random number generator inside the getRandomInt function\n\t\t\t\t\t\tgetRandomInt(1, 1000);\n\t\t\t\t\t}\n\t\t\t\t\trandomNumber = getRandomInt(1, 1000);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// init end\n\n\t\t\tfunction getRandomInt(min, max) {\n\t\t\t\tmin = Math.ceil(min);\n\t\t\t\tmax = Math.floor(max);\n\t\t\t\t//call our seeded random number generator\n\t\t\t\treturn Math.floor(rng() * (max - min) + min);\n\t\t\t}\n\n\t\t\tfunction onWindowResize( event ) {\n\n\t\t\t\tSCREEN_WIDTH = window.innerWidth;\n\t\t\t\tSCREEN_HEIGHT = window.innerHeight;\n\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\n\n\t\t\t\tcamera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;\n\t\t\t\tcamera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\t//animate with m\n\n\t\t\tfunction onKeyDown ( event ) {\n\n\t\t\t\tswitch( event.keyCode ) {\n\n\t\t\t\t\tcase 77: /*M*/  animDeltaDir *= -1; break;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t\t\t\t//State\n\t\t\t\t\t\tvar state = {\n\t\t\t\t\t\t\tpaused: false,\n\t\t\t\t\t\t\tpausedRenderer: false\n\t\t\t\t\t\t}\n\n\t\t\t\tvar fr = 0;\n\n\n\n\t\t\t// Take Data URL of Canvas\n\n\t\t\tfunction takeScreenshot( width, height, seed, page ) {\n\n\t\t\t    // set camera and renderer to desired screenshot dimension\n\t\t\t    camera.aspect = width / height;\n\t\t\t    camera.updateProjectionMatrix();\n\t\t\t \trenderer.setSize(  width, height );\n\n\n\t\t\t    renderer.render( scene, camera, null, false );\n\n\t\t\t    const dataURL = renderer.domElement.toDataURL( 'image/png' );\n\n\t\t\t    // save\n\t\t\t    saveDataURI(defaultFileName( '.png' , seed, page), dataURL);\n\n\t\t\t    // reset to old dimensions (cheat version)\n\t\t\t    onWindowResize();\n\n\t\t\t}\n\n\t\t\tfunction dataURIToBlob( dataURI ) {\n\t\t\t\tconst binStr = window.atob( dataURI.split( ',' )[1] );\n\t\t\t\tconst len = binStr.length;\n\t\t\t\tconst arr = new Uint8Array( len );\n\t\t\t\tfor ( let i = 0; i < len; i++ ) {\n\t\t\t\t\tarr[i] = binStr.charCodeAt( i );\n\t\t\t\t}\n\t\t\t\treturn new window.Blob( [arr] );\n\t\t\t}\n\n\n\t\t\t // Save Image into system\n\n\t\t\t function saveDataURI( name, dataURI ) {\n\t\t\t \tconst blob = dataURIToBlob( dataURI );\n\t\t\t  // force download\n\t\t\t  const link = document.createElement( 'a' );\n\t\t\t  link.download = name;\n\t\t\t  link.href = window.URL.createObjectURL( blob );\n\t\t\t  link.onclick = () => {\n\t\t\t  \twindow.setTimeout( () => {\n\t\t\t  \t\twindow.URL.revokeObjectURL( blob );\n\t\t\t  \t\tlink.removeAttribute( 'href' );\n\t\t\t  \t}, 500 );\n\n\t\t\t  };\n\t\t\t  link.click();\n\t\t\t}\n\n\t\t\t//return File Name\n\n\t\t\tfunction defaultFileName (ext, seed, page) {\n\t\t\t\t//var prng = new Math.seedrandom();\n\t\t\t\t//var randomNumber =  prng.int32();\n\t\t\t\tstr = `${seed}_${page}${ext}`;\n\t\t\t\treturn str;\n\t\t\t}\n\n\n\t\t\tvar frame = 0;\n\t\t\tfunction animate(){\n\t\t\t\trequestAnimationFrame( animate );\n\t\t\t\trender();\n\t\t\t\tframe++;\n\n\t\t\t}\n\n\n\t\t\tvar tookScreenshot = false;\n\t\t\tfunction render() {\n\n\t\t\t\tvar delta = clock.getDelta();\n\n\n\n\t\t\t\tif ( terrain.visible ) {\n\n\t\t\t\t\tcontrols.update();\n\n\t\t\t\t\tvar time = Date.now() * 0.001;\n\n\t\t\t\t\tvar fLow = 0.1, fHigh = 0.8;\n\n\t\t\t\t\tlightVal = THREE.Math.clamp( lightVal + 0.5 * delta * lightDir, fLow, fHigh );\n\n\t\t\t\t\tvar valNorm = ( lightVal - fLow ) / ( fHigh - fLow );\n\n\t\t\t\t\tscene.fog.color.setHSL( 0.1, 0.5, lightVal );\n\n\t\t\t\t\trenderer.setClearColor( scene.fog.color );\n\n\t\t\t\t\tdirectionalLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.1, 1.15 );\n\t\t\t\t\tpointLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.9, 1.5 );\n\n\t\t\t\t\tuniformsTerrain[ 'uNormalScale' ].value = THREE.Math.mapLinear( valNorm, 0, 1, 0.6, 3.5 );\n\n\t\t\t\t\tif ( updateNoise ) {\n\n\t\t\t\t\t\tanimDelta = THREE.Math.clamp( animDelta + 0.00075 * animDeltaDir, 0, 0.05 );\n\t\t\t\t\t\tuniformsNoise[ 'time' ].value += delta * animDelta;\n\n\t\t\t\t\t\tif(seed && page){\n\t\t\t\t\t\t\tif(!tookScreenshot){\n\t\t\t\t\t\t\t\tuniformsNoise[ 'offset' ].value.x = randomNumber * 0.05;\n\t\t\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\t\t\ttakeScreenshot( PAGE_WIDTH, PAGE_HEIGHT, seed, page);\n\t\t\t\t\t\t\t\t}, 500);\n\t\t\t\t\t\t\t\ttookScreenshot = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tuniformsNoise[ 'offset' ].value.x += delta * 0.05;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuniformsTerrain[ 'uOffset' ].value.x = 4 * uniformsNoise[ 'offset' ].value.x;\n\n\t\t\t\t\t\tquadTarget.material = mlib[ 'heightmap' ];\n\t\t\t\t\t\trenderer.render( sceneRenderTarget, cameraOrtho, heightMap, true );\n\n\t\t\t\t\t\tquadTarget.material = mlib[ 'normal' ];\n\t\t\t\t\t\trenderer.render( sceneRenderTarget, cameraOrtho, normalMap, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t\trenderer.render( scene, camera );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t</script>\n\n\t</body>\n</html>\n\n","url":"greed"}},"staticQueryHashes":[]}