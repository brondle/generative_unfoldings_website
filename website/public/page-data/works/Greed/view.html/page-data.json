{"componentChunkName":"component---src-templates-work-js","path":"/works/Greed/view.html","result":{"pageContext":{"pagePath":"works/Greed/view.html","content":"<!DOCTYPE HTML>\r\n<html lang=\"en\">\r\n\t<head>\r\n\t\t<title>Greed</title>\r\n\t\t<meta charset=\"utf-8\">\r\n\t\t<meta name=\"viewport\" content=\"width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0\">\r\n\t\t<style type=\"text/css\">\r\n\t\t\tbody {\r\n\t\t\t\tbackground: #000;\r\n\t\t\t\tcolor: #999;\r\n\t\t\t\tpadding: 0;\r\n\t\t\t\tmargin: 0;\r\n\t\t\t\toverflow: hidden;\r\n\t\t\t\tfont-family: georgia;\r\n\t\t\t\tfont-size:0.6em;\r\n\t\t\t\ttext-align: center;\r\n\t\t\t}\r\n\r\n\t\t\ta { color: #fb0; }\r\n\r\n\t\t\t#footer { position: absolute; bottom: 40px; width: 100%; }\r\n\t\t\t.h { color: #fb0 }\r\n\t\t\t.c { display: inline; margin-left: 1em }\r\n\r\n\t\t</style>\r\n\t</head>\r\n\r\n\t<body>\r\n\t\t<div id=\"container\"></div>\r\n\r\n\r\n\t\t<div id=\"footer\">\r\n\t\t\t<div class=\"c\">\r\n\t\t\tanimate terrain: <span class=\"h\">m</span>\r\n\t\t\t</div> &nbsp;&nbsp;&nbsp;&nbsp; rendered by <a href=\"http://threejs.org\" target=\"_blank\" rel=\"noopener\">three.js</a>  using\r\n\t\t\t\t\t\t<a href=\"https://github.com/ashima/webgl-noise\" target=\"_blank\" rel=\"noopener\">simplex noise</a><br/>\r\n\r\n\t\t\t\t\t\t<iframe src=\"sound.html\" width=\"100%\" height=\"0\" style=\"border:none;\">\r\n\t\t\t\t</iframe>\r\n\r\n\t\t\t</div>\r\n\r\n\r\n\t\t<script src=\"build/three.js\"></script>\r\n\r\n\t\t<script src=\"js/seedrandom.min.js\"></script>\r\n\r\n\t\t<script src=\"js/controls/OrbitControls.js\"></script>\r\n\r\n\t\t<script src=\"js/BufferGeometryUtils.js\"></script>\r\n\r\n\t\t<script src=\"js/shaders/NormalMapShader.js\"></script>\r\n\r\n\t\t<script src=\"js/ShaderTerrain.js\"></script>\r\n\r\n\t\t<script src=\"js/Detector.js\"></script>\r\n\r\n\r\n\t\t<script id=\"fragmentShaderNoise\" type=\"x-shader/x-fragment\">\r\n\r\n\t\t\t//\r\n\t\t\t// Description : Array and textureless GLSL 3D simplex noise function.\r\n\t\t\t//      Author : Ian McEwan, Ashima Arts.\r\n\t\t\t//  Maintainer : ijm\r\n\t\t\t//     Lastmod : 20110409 (stegu)\r\n\t\t\t//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\r\n\t\t\t//               Distributed under the MIT License. See LICENSE file.\r\n\t\t\t//\r\n\r\n\t\t\tuniform float time;\r\n\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\tvec4 permute( vec4 x ) {\r\n\r\n\t\t\t\treturn mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvec4 taylorInvSqrt( vec4 r ) {\r\n\r\n\t\t\t\treturn 1.79284291400159 - 0.85373472095314 * r;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloat snoise( vec3 v ) {\r\n\r\n\t\t\t\tconst vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\r\n\t\t\t\tconst vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );\r\n\r\n\t\t\t\t// First corner\r\n\r\n\t\t\t\tvec3 i  = floor( v + dot( v, C.yyy ) );\r\n\t\t\t\tvec3 x0 = v - i + dot( i, C.xxx );\r\n\r\n\t\t\t\t// Other corners\r\n\r\n\t\t\t\tvec3 g = step( x0.yzx, x0.xyz );\r\n\t\t\t\tvec3 l = 1.0 - g;\r\n\t\t\t\tvec3 i1 = min( g.xyz, l.zxy );\r\n\t\t\t\tvec3 i2 = max( g.xyz, l.zxy );\r\n\r\n\t\t\t\tvec3 x1 = x0 - i1 + 1.0 * C.xxx;\r\n\t\t\t\tvec3 x2 = x0 - i2 + 2.0 * C.xxx;\r\n\t\t\t\tvec3 x3 = x0 - 1. + 3.0 * C.xxx;\r\n\r\n\t\t\t\t// Permutations\r\n\r\n\t\t\t\ti = mod( i, 289.0 );\r\n\t\t\t\tvec4 p = permute( permute( permute(\r\n\t\t\t\t\t\t i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )\r\n\t\t\t\t\t   + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )\r\n\t\t\t\t\t   + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\r\n\r\n\t\t\t\t// Gradients\r\n\t\t\t\t// ( N*N points uniformly over a square, mapped onto an octahedron.)\r\n\r\n\t\t\t\tfloat n_ = 1.0 / 7.0; // N=7\r\n\r\n\t\t\t\tvec3 ns = n_ * D.wyz - D.xzx;\r\n\r\n\t\t\t\tvec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)\r\n\r\n\t\t\t\tvec4 x_ = floor( j * ns.z );\r\n\t\t\t\tvec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)\r\n\r\n\t\t\t\tvec4 x = x_ *ns.x + ns.yyyy;\r\n\t\t\t\tvec4 y = y_ *ns.x + ns.yyyy;\r\n\t\t\t\tvec4 h = 1.0 - abs( x ) - abs( y );\r\n\r\n\t\t\t\tvec4 b0 = vec4( x.xy, y.xy );\r\n\t\t\t\tvec4 b1 = vec4( x.zw, y.zw );\r\n\r\n\r\n\t\t\t\tvec4 s0 = floor( b0 ) * 2.0 + 1.0;\r\n\t\t\t\tvec4 s1 = floor( b1 ) * 2.0 + 1.0;\r\n\t\t\t\tvec4 sh = -step( h, vec4( 0.0 ) );\r\n\r\n\t\t\t\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\r\n\t\t\t\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\r\n\r\n\t\t\t\tvec3 p0 = vec3( a0.xy, h.x );\r\n\t\t\t\tvec3 p1 = vec3( a0.zw, h.y );\r\n\t\t\t\tvec3 p2 = vec3( a1.xy, h.z );\r\n\t\t\t\tvec3 p3 = vec3( a1.zw, h.w );\r\n\r\n\t\t\t\t// Normalise gradients\r\n\r\n\t\t\t\tvec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\r\n\t\t\t\tp0 *= norm.x;\r\n\t\t\t\tp1 *= norm.y;\r\n\t\t\t\tp2 *= norm.z;\r\n\t\t\t\tp3 *= norm.w;\r\n\r\n\t\t\t\t// Mix final noise value\r\n\r\n\t\t\t\tvec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\r\n\t\t\t\tm = m * m;\r\n\t\t\t\treturn 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),\r\n\t\t\t\t\t\t\t\t\t\t\t  dot( p2, x2 ), dot( p3, x3 ) ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloat surface3( vec3 coord ) {\r\n\r\n\t\t\t\tfloat n = 0.0;\r\n\r\n\t\t\t\tn += 1.0 * abs( snoise( coord ) );\r\n\t\t\t\tn += 0.5 * abs( snoise( coord * 2.0 ) );\r\n\t\t\t\tn += 0.25 * abs( snoise( coord * 4.0 ) );\r\n\t\t\t\tn += 0.125 * abs( snoise( coord * 8.0 ) );\r\n\r\n\t\t\t\treturn n;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvoid main( void ) {\r\n\r\n\t\t\t\tvec3 coord = vec3( vUv, -time );\r\n\t\t\t\tfloat n = surface3( coord );\r\n\r\n\t\t\t\tgl_FragColor = vec4( vec3( n, n, n ), 1.0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t</script>\r\n\r\n\r\n\t\t<script id=\"vertexShader\" type=\"x-shader/x-vertex\">\r\n\r\n\t\t\tvarying vec2 vUv;\r\n\t\t\tuniform vec2 scale;\r\n\t\t\tuniform vec2 offset;\r\n\r\n\t\t\tvoid main( void ) {\r\n\r\n\t\t\t\tvUv = uv * scale + offset;\r\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t</script>\r\n\r\n\t\t<script>\r\n\r\n\t\t\tif ( ! Detector.webgl ) Detector.addGetWebGLMessage();\r\n\r\n\t\t\tvar SCREEN_WIDTH = window.innerWidth;\r\n\t\t\tvar SCREEN_HEIGHT = window.innerHeight;\r\n\r\n\t\t\tvar renderer, container, stats;\r\n\r\n\t\t\tvar camera, scene, controls;\r\n\t\t\tvar cameraOrtho, sceneRenderTarget;\r\n\r\n\t\t\tvar uniformsNoise, uniformsNormal, uniformsTerrain,\r\n\t\t\t\theightMap, normalMap,\r\n\t\t\t\tquadTarget;\r\n\r\n\t\t\tvar directionalLight, pointLight;\r\n\r\n\t\t\tvar terrain;\r\n\r\n\t\t\tvar textureCounter = 0;\r\n\r\n\t\t\tvar animDelta = 0, animDeltaDir = -1;\r\n\t\t\tvar lightVal = 0, lightDir = 1;\r\n\r\n\t\t\tvar clock = new THREE.Clock();\r\n\r\n\t\t\tvar updateNoise = true;\r\n\r\n\t\t\tvar animateTerrain = false;\r\n\r\n\t\t\tvar mlib = {};\r\n\r\n\t\t\tconst urlParams = new URLSearchParams(location.search);\r\n\t\t\tconst seed = parseInt(urlParams.get(\"seed\"));\r\n\t\t\tconst page = parseInt(urlParams.get(\"page\"));\r\n\t\t\t//create a random number generator with our designated seed\r\n\t\t\tconst rng = new Math.seedrandom(seed);\r\n\t\t\tvar screenshotFrame;\r\n\r\n\t\t\tinit();\r\n\t\t\tanimate();\r\n\r\n\t\t\tfunction init() {\r\n\r\n\t\t\t\tcontainer = document.getElementById( 'container' );\r\n\r\n\t\t\t\t// SCENE (RENDER TARGET)\r\n\r\n\t\t\t\tsceneRenderTarget = new THREE.Scene();\r\n\r\n\t\t\t\tcameraOrtho = new THREE.OrthographicCamera( SCREEN_WIDTH / - 2, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, SCREEN_HEIGHT / - 2, -10000, 10000 );\r\n\t\t\t\tcameraOrtho.position.z = 100;\r\n\r\n\t\t\t\tsceneRenderTarget.add( cameraOrtho );\r\n\r\n\t\t\t\t// CAMERA\r\n\r\n\t\t\t\tcamera = new THREE.PerspectiveCamera( 40, SCREEN_WIDTH / SCREEN_HEIGHT, 2, 4000 );\r\n\t\t\t\tcamera.position.set( -1200, 500, 1000 );// ( -1200, 800, 1200 )\r\n\r\n\t\t\t\tcontrols = new THREE.OrbitControls( camera );\r\n\t\t\t\tcontrols.target.set( 0, 0, 0 );\r\n\r\n\t\t\t\tcontrols.enableRotate = true;\r\n\t\t\t\t//adding a bit of heaviness here (heft)\r\n\t\t\t\tcontrols.rotateSpeed = 0.05;\r\n\t\t\t\tcontrols.minAzimuthAngle = - Math.PI; // default\r\n\t\t\t\tcontrols.maxAzimuthAngle = Math.PI / 2;\r\n\r\n\t\t\t\tcontrols.minPolarAngle = 0; // default\r\n\t\t\t\tcontrols.maxPolarAngle = Math.PI / 3;\r\n\r\n        //and a bit of heaviness here\r\n\t\t\t\tcontrols.zoomSpeed = 0.05;\r\n\r\n\t\t\t\tcontrols.panSpeed = 0.5;\r\n\r\n\t\t\t\tcontrols.enableKeys= true;\r\n\t\t\t\tcontrols.keys = [ 37, 38, 39 ];\r\n\r\n\t\t\t\t// SCENE (FINAL)\r\n\r\n\t\t\t\tscene = new THREE.Scene();\r\n\t\t\t\tscene.fog = new THREE.Fog( 0x050505, 2000, 4000 );\r\n\r\n\t\t\t\t// LIGHTS\r\n\r\n\t\t\t\tscene.add( new THREE.AmbientLight( 0x111111 ) );\r\n\r\n\t\t\t\tdirectionalLight = new THREE.DirectionalLight( 0xffffff, 1.15 );\r\n\t\t\t\tdirectionalLight.position.set( 500, 2000, 0 );\r\n\t\t\t\tscene.add( directionalLight );\r\n\r\n\t\t\t\tpointLight = new THREE.PointLight( 0xff4400, 1.5 );\r\n\t\t\t\tpointLight.position.set( 0, 0, 0 );\r\n\t\t\t\tscene.add( pointLight );\r\n\r\n\r\n\t\t\t\t// HEIGHT + NORMAL MAPS\r\n\r\n\t\t\t\tvar normalShader = THREE.NormalMapShader;\r\n\r\n\t\t\t\tvar rx = 256, ry = 256;\r\n\t\t\t\t// var rx = 2412, ry = 3074;\r\n\t\t\t\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };\r\n\r\n\t\t\t\theightMap  = new THREE.WebGLRenderTarget( rx, ry, pars );\r\n\t\t\t\theightMap.texture.generateMipmaps = false;\r\n\r\n\t\t\t\tnormalMap = new THREE.WebGLRenderTarget( rx, ry, pars );\r\n\t\t\t\tnormalMap.texture.generateMipmaps = false;\r\n\r\n\t\t\t\tuniformsNoise = {\r\n\r\n\t\t\t\t\ttime:   { value: 1.0 },\r\n\t\t\t\t\tscale:  { value: new THREE.Vector2( 1.5, 1.5 ) },\r\n\t\t\t\t\toffset: { value: new THREE.Vector2( 0, 0 ) }\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\tuniformsNormal = THREE.UniformsUtils.clone( normalShader.uniforms );\r\n\r\n\t\t\t\tuniformsNormal.height.value = 0.05;\r\n\t\t\t\tuniformsNormal.resolution.value.set( rx, ry );\r\n\t\t\t\tuniformsNormal.heightMap.value = heightMap.texture;\r\n\r\n\t\t\t\tvar vertexShader = document.getElementById( 'vertexShader' ).textContent;\r\n\r\n\t\t\t\t// TEXTURES\r\n\r\n\t\t\t\tvar loadingManager = new THREE.LoadingManager( function(){\r\n\t\t\t\t\tterrain.visible = true;\r\n\t\t\t\t});\r\n\t\t\t\tvar textureLoader = new THREE.TextureLoader( loadingManager );\r\n\r\n\t\t\t\tvar specularMap = new THREE.WebGLRenderTarget( 1024, 1024, pars );\r\n\t\t\t\tspecularMap.texture.generateMipmaps = false;\r\n\r\n\t\t\t\tvar diffuseTexture1 = textureLoader.load( \"./textures/difTex001.png\" );\r\n\t\t\t\tvar diffuseTexture2 = textureLoader.load( \"./textures/difTex002.png\" );\r\n\t\t\t\t//on purpose here\r\n\t\t\t\tvar detailTexture = textureLoader.load( \"textures/consenttocollectmydata.png\" );\r\n\r\n\t\t\t\tdiffuseTexture1.wrapS = diffuseTexture1.wrapT = THREE.RepeatWrapping;\r\n\t\t\t\tdiffuseTexture2.wrapS = diffuseTexture2.wrapT = THREE.RepeatWrapping;\r\n\t\t\t\tdetailTexture.wrapS = detailTexture.wrapT = THREE.RepeatWrapping;\r\n\t\t\t\tspecularMap.texture.wrapS = specularMap.texture.wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t\t// TERRAIN SHADER\r\n\r\n\t\t\t\tvar terrainShader = THREE.ShaderTerrain[ \"terrain\" ];\r\n\r\n\t\t\t\tuniformsTerrain = THREE.UniformsUtils.clone( terrainShader.uniforms );\r\n\r\n\t\t\t\tuniformsTerrain[ 'tNormal' ].value = normalMap.texture;\r\n\t\t\t\tuniformsTerrain[ 'uNormalScale' ].value = 3.5;\r\n\r\n\t\t\t\tuniformsTerrain[ 'tDisplacement' ].value = heightMap.texture;\r\n\r\n\t\t\t\tuniformsTerrain[ 'tDiffuse1' ].value = diffuseTexture1;\r\n\t\t\t\tuniformsTerrain[ 'tDiffuse2' ].value = diffuseTexture2;\r\n\t\t\t\tuniformsTerrain[ 'tSpecular' ].value = specularMap.texture;\r\n\t\t\t\tuniformsTerrain[ 'tDetail' ].value = detailTexture;\r\n\r\n\t\t\t\tuniformsTerrain[ 'enableDiffuse1' ].value = true;\r\n\t\t\t\tuniformsTerrain[ 'enableDiffuse2' ].value = true;\r\n\t\t\t\tuniformsTerrain[ 'enableSpecular' ].value = true;\r\n\r\n\t\t\t\tuniformsTerrain[ 'diffuse' ].value.setHex( 0xffffff );\r\n\t\t\t\tuniformsTerrain[ 'specular' ].value.setHex( 0xffffff );\r\n\r\n\t\t\t\tuniformsTerrain[ 'shininess' ].value = 30;\r\n\r\n\t\t\t\tuniformsTerrain[ 'uDisplacementScale' ].value = 375;\r\n\r\n\t\t\t\tuniformsTerrain[ 'uRepeatOverlay' ].value.set( 6, 6 );\r\n\r\n\t\t\t\tvar params = [\r\n\t\t\t\t\t[ 'heightmap', \tdocument.getElementById( 'fragmentShaderNoise' ).textContent, \tvertexShader, uniformsNoise, false ],\r\n\t\t\t\t\t[ 'normal', \tnormalShader.fragmentShader,  normalShader.vertexShader, uniformsNormal, false ],\r\n\t\t\t\t\t[ 'terrain', \tterrainShader.fragmentShader, terrainShader.vertexShader, uniformsTerrain, true ]\r\n\t\t\t\t ];\r\n\r\n\t\t\t\tfor( var i = 0; i < params.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar material = new THREE.ShaderMaterial( {\r\n\r\n\t\t\t\t\t\tuniforms: \t\tparams[ i ][ 3 ],\r\n\t\t\t\t\t\tvertexShader: \tparams[ i ][ 2 ],\r\n\t\t\t\t\t\tfragmentShader: params[ i ][ 1 ],\r\n\t\t\t\t\t\tlights: \t\tparams[ i ][ 4 ],\r\n\t\t\t\t\t\tfog: \t\t\ttrue\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\tmlib[ params[ i ][ 0 ] ] = material;\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tvar plane = new THREE.PlaneBufferGeometry( SCREEN_WIDTH, SCREEN_HEIGHT );\r\n\r\n\t\t\t\tquadTarget = new THREE.Mesh( plane, new THREE.MeshBasicMaterial( { color: 0x000000 } ) );\r\n\t\t\t\tquadTarget.position.z = -500;\r\n\t\t\t\tsceneRenderTarget.add( quadTarget );\r\n\r\n\t\t\t\t// TERRAIN MESH\r\n\r\n\t\t\t\tvar geometryTerrain = new THREE.PlaneBufferGeometry( 9000, 9000, 256, 256 );\r\n\r\n\t\t\t\tTHREE.BufferGeometryUtils.computeTangents( geometryTerrain );\r\n\r\n\t\t\t\tterrain = new THREE.Mesh( geometryTerrain, mlib[ 'terrain' ] );\r\n\t\t\t\tterrain.position.set( 0, -125, 0 );\r\n\t\t\t\tterrain.rotation.x = -Math.PI / 2;\r\n\t\t\t\tterrain.visible = false;\r\n\t\t\t\tscene.add( terrain );\r\n\r\n\t\t\t\t// RENDERER\r\n\r\n\t\t\t\trenderer = new THREE.WebGLRenderer();\r\n\t\t\t\trenderer.setClearColor( scene.fog.color );\r\n\t\t\t\trenderer.setPixelRatio( window.devicePixelRatio );\r\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\r\n\t\t\t\tcontainer.appendChild( renderer.domElement );\r\n\r\n\r\n\t\t\t\t// EVENTS\r\n\r\n\t\t\t\tonWindowResize();\r\n\r\n\t\t\t\twindow.addEventListener( 'resize', onWindowResize, false );\r\n\r\n        document.addEventListener( 'keydown', onKeyDown, false );\r\n\r\n\t\t\t\tif (seed && page) {\r\n\t\t\t\t\tfor (var i = 1; i <= page - 1; i++) {\r\n\t\t\t\t\t\t// every time this is called, it hits our random number generator inside the getRandomInt function\r\n\t\t\t\t\t\tgetRandomInt(50, 500);\r\n\r\n\t\t\t\t\t    //console.log(getRandomInt(100, 1000));\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// will take screenshot between frame 100 and 1000\r\n\t\t\t\t\tscreenshotFrame = getRandomInt(50, 500);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t// init end\r\n\r\n\t\t\tfunction getRandomInt(min, max) {\r\n\t\t\t\tmin = Math.ceil(min);\r\n\t\t\t\tmax = Math.floor(max);\r\n\t\t\t\t//call our seeded random number generator\r\n\t\t\t\treturn Math.floor(rng() * (max - min) + min);\r\n\t\t\t}\r\n\r\n\t\t\tfunction onWindowResize( event ) {\r\n\r\n\t\t\t\tSCREEN_WIDTH = window.innerWidth;\r\n\t\t\t\tSCREEN_HEIGHT = window.innerHeight;\r\n\r\n\t\t\t\trenderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );\r\n\r\n\t\t\t\tcamera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;\r\n\t\t\t\tcamera.updateProjectionMatrix();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//animate with m\r\n\r\n\t\t\tfunction onKeyDown ( event ) {\r\n          v = event.keyCode\r\n\r\n\t\t\t\tswitch( event.keyCode ) {\r\n\t\t\t\t\tcase 77: /*M*/  animDeltaDir *= -1; break;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t//State\r\n\t\t\t\t\t\tvar state = {\r\n\t\t\t\t\t\t\tpaused: false,\r\n\t\t\t\t\t\t\tpausedRenderer: false\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\tvar fr = 0;\r\n\r\n\r\n\r\n\t\t\t// Take Data URL of Canvas\r\n\r\n\t\t\tfunction takeScreenshot( width, height, seed, page ) {\r\n\r\n\t\t\t    // set camera and renderer to desired screenshot dimension\r\n\t\t\t    camera.aspect = width / height;\r\n\t\t\t    camera.updateProjectionMatrix();\r\n\t\t\t    // renderer.setSize(  width, height );\r\n\t\t\t\trenderer.setSize(  2412, 3074 );\r\n\r\n\r\n\t\t\t    renderer.render( scene, camera, null, false );\r\n\r\n\t\t\t    const dataURL = renderer.domElement.toDataURL( 'image/png' );\r\n\r\n\t\t\t    // save\r\n\t\t\t    saveDataURI(defaultFileName( '.png' , seed, page), dataURL);\r\n\r\n\t\t\t    // reset to old dimensions (cheat version)\r\n\t\t\t    onWindowResize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction dataURIToBlob( dataURI ) {\r\n\t\t\t\tconst binStr = window.atob( dataURI.split( ',' )[1] );\r\n\t\t\t\tconst len = binStr.length;\r\n\t\t\t\tconst arr = new Uint8Array( len );\r\n\t\t\t\tfor ( let i = 0; i < len; i++ ) {\r\n\t\t\t\t\tarr[i] = binStr.charCodeAt( i );\r\n\t\t\t\t}\r\n\t\t\t\treturn new window.Blob( [arr] );\r\n\t\t\t}\r\n\r\n\r\n\t\t\t // Save Image into system\r\n\r\n\t\t\t function saveDataURI( name, dataURI ) {\r\n\t\t\t \tconst blob = dataURIToBlob( dataURI );\r\n\t\t\t  // force download\r\n\t\t\t  const link = document.createElement( 'a' );\r\n\t\t\t  link.download = name;\r\n\t\t\t  link.href = window.URL.createObjectURL( blob );\r\n\t\t\t  link.onclick = () => {\r\n\t\t\t  \twindow.setTimeout( () => {\r\n\t\t\t  \t\twindow.URL.revokeObjectURL( blob );\r\n\t\t\t  \t\tlink.removeAttribute( 'href' );\r\n\t\t\t  \t}, 500 );\r\n\r\n\t\t\t  };\r\n\t\t\t  link.click();\r\n\t\t\t}\r\n\r\n\t\t\t//return File Name\r\n\r\n\t\t\tfunction defaultFileName (ext, seed, page) {\r\n\t\t\t\tvar prng = new Math.seedrandom();\r\n\t\t\t\tvar randomNumber =  prng.int32();\r\n\t\t\t\tstr = `${seed}_${page}${ext}`;\r\n\t\t\t\treturn str;\r\n\t\t\t}\r\n\r\n\r\n\t\t\tvar frame = 0;\r\n\t\t\tfunction animate(){\r\n\r\n\t\t\tif (screenshotFrame !== undefined && frame === screenshotFrame) {\r\n\t\t\t\ttakeScreenshot( SCREEN_WIDTH, SCREEN_HEIGHT, seed, page);\r\n\t\t\t\trequestAnimationFrame( animate );\r\n\t\t\t\trender();\r\n\t\t\t} else {\r\n\t\t\t\trequestAnimationFrame( animate );\r\n\t\t\t\trender();\r\n\t\t\t}\r\n\t\t\tframe++;\r\n\r\n\t\t\t}\r\n\r\n\r\n\r\n\t\t\tfunction render() {\r\n\r\n\t\t\t\tvar delta = clock.getDelta();\r\n\r\n\r\n\r\n\t\t\t\tif ( terrain.visible ) {\r\n\r\n\t\t\t\t\tcontrols.update();\r\n\r\n\t\t\t\t\tvar time = Date.now() * 0.001;\r\n\r\n\t\t\t\t\tvar fLow = 0.1, fHigh = 0.8;\r\n\r\n\t\t\t\t\tlightVal = THREE.Math.clamp( lightVal + 0.5 * delta * lightDir, fLow, fHigh );\r\n\r\n\t\t\t\t\tvar valNorm = ( lightVal - fLow ) / ( fHigh - fLow );\r\n\r\n\t\t\t\t\tscene.fog.color.setHSL( 0.1, 0.5, lightVal );\r\n\r\n\t\t\t\t\trenderer.setClearColor( scene.fog.color );\r\n\r\n\t\t\t\t\tdirectionalLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.1, 1.15 );\r\n\t\t\t\t\tpointLight.intensity = THREE.Math.mapLinear( valNorm, 0, 1, 0.9, 1.5 );\r\n\r\n\t\t\t\t\tuniformsTerrain[ 'uNormalScale' ].value = THREE.Math.mapLinear( valNorm, 0, 1, 0.6, 3.5 );\r\n\r\n\t\t\t\t\tif ( updateNoise ) {\r\n\r\n\t\t\t\t\t\tanimDelta = THREE.Math.clamp( animDelta + 0.00075 * animDeltaDir, 0, 0.05 );\r\n\t\t\t\t\t\tuniformsNoise[ 'time' ].value += delta * animDelta;\r\n\r\n\t\t\t\t\t\tuniformsNoise[ 'offset' ].value.x += delta * 0.05;\r\n\r\n\t\t\t\t\t\tuniformsTerrain[ 'uOffset' ].value.x = 4 * uniformsNoise[ 'offset' ].value.x;\r\n\r\n\t\t\t\t\t\tquadTarget.material = mlib[ 'heightmap' ];\r\n\t\t\t\t\t\trenderer.render( sceneRenderTarget, cameraOrtho, heightMap, true );\r\n\r\n\t\t\t\t\t\tquadTarget.material = mlib[ 'normal' ];\r\n\t\t\t\t\t\trenderer.render( sceneRenderTarget, cameraOrtho, normalMap, true );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\trenderer.render( scene, camera );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t</script>\r\n\r\n\t</body>\r\n</html>\r\n","url":"Greed"}},"staticQueryHashes":[]}